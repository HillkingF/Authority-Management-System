# “AMS” 前端开发手册



## 1. 简介

AMS是一个博客后台权限管理系统。

可管理三种用户：

- 主人：拥有所有权限（增删改查）
- 游客：只有查看权限
- 登录用户：用于查看权限和部分编辑功能

技术栈：

- Vue

开发环境：

- windows10





下面开始开发啦！









## 2. 创建新项目，搭建基础环境

需要安装的东西：

- Node.js：是一个基于Chrome V8引擎的[JavaScript](https://baike.baidu.com/item/JavaScript/321142)运行环境
- NPM：是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题
- Node.js 淘宝镜像加速器（cnpm）：简单理解为npm的备用版本
- vue-cli：这里安装3以上的版本，可以使用vue-ui可视化窗口
- IDEA安装vue插件
- Element-ui：UI组件库，类似BootStrap
- axios：一个基于 promise 的 HTTP 库，类ajax。进行前后端对接的时候，使用这个工具可以提高我们的开发效率
- qs：查询参数序列化和解析库
- mockjs：为我们生成随机数据的工具库
- vue-router：vue路由，用于页面之间的交互连接

------

### 2.1 安装Node.js及NPM

由于新版的nodejs已经集成了npm，所以安装NodeJS的同时NPN也一并安装好了。

1. 官网`http://nodejs.cn/download`下载64位安装包，无脑安装即可。

2. cmd下输入 `node -v`，查看是否能够正确打印版本号即可，如下图

3. cmd下输入 `npm -v`，查看是否能够正常打印版本号即可，如下图

![image-20210506161334107](img/image-20210506161334107.png)



### 2.2 淘宝镜像加速器 cnpm

npm安装插件过程：从[http://registry.npmjs.org](http://registry.npmjs.org/)下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常），解决办法就是用cnpm代替。

所以cnpm可以理解为npm的加速版本，出现下载不了的情况时，可以用cnpm代替。

在cmd中输入下面的命令安装（推荐使用第一条命令）：

```cmd
# 推荐：-g 就是全局安装
npm install cnpm -g
# 不推荐：使用如下语句解决npm速度慢的问题(每次安装的时候都带上)
npm install --registry=https://registry.npm.taobao.org
```

安装成功结果如下。划线路径是cnpm的默认安装位置（安装在隐藏目录中）

![image-20210506161949891](img/image-20210506161949891.png)



### 2.3 SPSS 加载器

```cmd
# 安装 SPSS 加载器
cnpm install sass-loader node-sass --save-dev
```





### 2.4 安装 vue-cli

Vue CLI官网有安装教程：https://cli.vuejs.org/zh/

安装低版本（3以下的版本）：

```cmd
# cmd下使用下面的命令安装vue-cli：
cnpm install vue-cli -g

# 测试是否安装成功
# 查看可以基于哪些模板创建 vue 应用程序，通常选择 webpack
vue list

# 查看 vue版本：2.9.6
vue -V   

# 查看是否有ui功能。Commands中不含有ui说明vue版本低于3时没有ui功能
vue -h
```

安装最新版本vue-cli 3.0+：

```cmd
# 3卸载老版本
npm uninstall vue-cli -g
# 下载安装3以上的版本用下面的新命令：
npm install -g @vue/cli
# 打开vue ui: 浏览器会弹出一个Vue项目管理器
vue ui
```



### 2.5 创建vue项目

1. 选定目标位置打开cmd：

   `D:\Github\GitRepository\Authority-Management-System`中打开cmd

2. 在目标位置打开vue可视化管理窗口，这样vue ui 和 vue项目就在同一级，方便管理切换：

   ![image-20210507191200960](img/image-20210507191200960.png)

3. 浏览器弹出可视化窗口。在"创建"下确定项目目标位置，然后点击"+在此创建新项目"：

   ![image-20210507191459789](img/image-20210507191459789.png)

4. 在下图输入项目名字，自己选择相关配置，然后点击下一步

   ![image-20210507191830215](img/image-20210507191830215.png)

5. 预设中选择手动->下一步

6. 勾选上路由Router、状态管理Vuex，去掉js的校验

   ![image-20210507192137181](img/image-20210507192137181.png)

7. 下一步中，选上【Use history mode for router】，点击创建项目->弹窗中选择按钮【创建项目，不保存预设】

8. 等待项目创建完成后。在目标位置下会生成这个新项目。这样我们就创建好基础工程了

   ![image-20210507192534780](img/image-20210507192534780.png)

9. admin-vue项目目录说明：

   - `node_modules`：是安装node后用来存放用包管理工具下载安装的包的文件夹。比如webpack、gulp、grunt这些工具。

     npm install 执行完毕后，我们可以在 node_modules 中看到所有依赖的包。

   - `public`：静态资源目录，build之后，public下面的文件会原封不动的添加到dist中，不会被合并、压缩；多用来存放第三方插件。

   - `src`：代码存放路径

     - `assets`：多用来存放业务级的js、css等，如一些全局的scss样式文件、全局的工具类js文件等。
     - `components`：存放通用的组件
     - `router`：存放路由文件
     - `store`：存放 vuex，应用级数据（state）
     - `views`：存放前端页面
     - `app.vue`：使用标签<route-view></router-view>渲染整个工程的.vue组件
     - `main.js`：程序主入口。作用是创建vue实例

   - `package.json`：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理



### 2.6 IDEA安装Vue插件

IDEA要预先先安装好一个Vue插件：

settings->Plugins->搜索vue->安装install



### 2.7 IDEA运行vue

IDEA打开`admin-vue`项目。

在终端Terminal窗口中启动vue项目，输入如下命令：

````cmd
# 3之前的的版本可能是`npm run dev`
# 由于不同版本vue-cli中的package.json中：
# "scripts": {
#   "serve": "vue-cli-service serve",
#   "build": "vue-cli-service build"
# },
# 而 npm run xxx 中的 xxx就是scripts中的键。
# 所以版本不同，vue程序启动的命令也不同
npm run serve  
````

运行成功后终端显示如下：

![image-20210507195731070](img/image-20210507195731070.png)



因此，浏览器可以访问上面两个网址查看成功启动的效果：

  - Local:   http://localhost:8080/
  - Network: http://10.11.8.54:8080/

![image-20210507195910926](img/image-20210507195910926.png)





### 2.8 安装Element-ui并初始化

Element-ui官网文档有详细的安装使用过程：https://element.eleme.cn

本项目的安装步骤：

```cmd
# 1.进入工程目录
cd admin-vue
# 2.安装 element-ui
npm i element-ui -S  #或者cnpm install element-ui --save

# 2.安装 vue-router
npm install vue-router --save-dev
# 4.安装依赖
npm install
# 5.安装 SPSS 加载器
cnpm install sass-loader node-sass --save-dev
```

在src目录下的程序主入口`main.js`，引入element-ui依赖并显式使用：

```js
import Element from 'element-ui'
import "element-ui/lib/theme-chalk/index.css"
Vue.use(Element)
```





### 2.9 安装axios、qs、mockjs

#### 2.9.1 安装axios	

```
ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。axios：提供了一些并发请求的接口（重要，方便了很多的操作）
所以：axios是用于网页异步刷新的
```

axios官网：http://www.axios-js.com/

官网最新cmd安装命令： 

```cmd
npm install axios
```

然后同样在main.js中全局引入axios:

```js
import axios from 'axios'
Vue.prototype.$axios = axios 
```

#### 2.9.2 安装qs

简单来说，qs 是一个增加了一些安全性的查询字符串解析和序列化字符串的库。

```cmd
npm install qs --save # cnpm install qs --save
```

#### 2.9.3 安装mockjs

mockjs官网：http://mockjs.com/

后台现在还没有搭建，无法与前端完成数据交互。因此引入mockjs方便后续提供api返回数据。

```cmd
npm install mockjs --save-dev # 或cnpm 
```

在src目录下新建mock.js文件，用于编写随机数据的api

在main.js中引入这个文件：

```js
require("./mock") //引入mock数据，关闭则注释该行
```



### 2.10 安装router

#### 步骤

vue路由：用于页面之间的交互连接

由于创建项目的时候我们已经安装了router，所以这里不用安装了。

如果没有安装router，则按照下面的步骤安装router！

1. 查看项目的`node_modules`目录中是否存在`vue-router`。如果不存在执行第2步

2. cmd进入项目中，执行以下命令：

   ```cmd
   npm install vue-router --save-dev
   ```

3. `router`目录下创建`index.js`等路由配置文件。

   ```js
   // 1.显式的导入vue和VueRouter包
   import Vue from 'vue'
   import VueRouter from 'vue-router'
   
   // 3. 导入要跳转的组件文件
   
   // 2. 必须显式声明安装使用路由功能
   Vue.use(VueRouter);
   
   // 4. 配置导出路由,这样别人才能通过路由,直接从前端进行组件跳转而不用在后端跳转
   export default new VueRouter({
     routes: [
       {
         path: '/content',   // 请求路径
         name: 'content',
         component: Content  // 跳转的组件
       },
       {
       }
     ]
   });
   ```

4. 在全局入口配置路由`main.js`

   ```js
   import router from './router'   // 1
   new Vue({
     router,   
   })
   ```

5. 通过路由在App.vue页面实现跳转

   ```vue
   <template>
     <div id="app">
       <div id="nav">
         <router-link to="/">Home</router-link> |
         <router-link to="/about">About</router-link>
       </div>
       <router-view/>
     </div>
   </template>
   ```



#### **路由小结：**

如何安装配置并使用路由功能？

- router的index.js：
  - 导入vue页面
  - 配置路由跳转
- 全局入口main.js配置路由：
  - 导入router包
  - vue对象中增加router
- 在某个vue页面中创建路由链接并显示
  - router-link
  - router-view





### 现在我们的vue项目基础结构构建好了！





## 3、前端页面开发

**页面显示流程：**

- 程序启动后，最底层显示的是vue自带的APP.vue;

- App.vue有三个子页面：home、login、about。当浏览器请求这三个页面时，会先显示APP.vue,再显示这三个页面；

- 而当请求index.vue时，由于其是home页面的子页面，所以会先显示app页面，然后显示home页面，最后渲染index页面，所以尽管index只有一行代码，但是仍能显示home的底层页面。

**也就是说：多级嵌套的路由会先显示底层的父级页面模板，再叠加渲染子级模板。下面实践说明！**



前端页面基本创建在views目录下面，下面依次创建这些页面！

### 3.1 默认显示的首页

==src/views/Index.vue==

这个页面暂时没什么用，之后修改

#### Ⅰ. 创建页面

```vue
<template>
  <h1>默认显示页面index.vue</h1>
</template>

<script>
export default {
  name: "Index"
}
</script>

<style scoped>

</style>
```

#### Ⅱ. 配置路由

```js
import Index from '../views/Index.vue'  // 1.默认显示页面
  {
    path: '/index',
    name: 'Index',
    component: Index
  },
```







### 3.2 登录首页

==src/views/Login.vue==

#### Ⅰ. 创建基础页面

使用带有参数校验的表单：在防止用户犯错的前提下，尽可能让用户更早地发现并纠正错误。

Form 组件提供了表单验证的功能，只需要通过 `rules` 属性传入约定的验证规则，并将 Form-Item 的 `prop` 属性设置为需校验的字段名即可。校验规则参见 [async-validator](https://github.com/yiminghe/async-validator)

```
Login.vue
</template>中是组件模板
<script>data()接收表单返回值：
- loginForm: 接收从前端绑定的表单数据
- rules：定义表单校验规则
```

```vue
<template>
  <!--template 只能有一个直系儿子-->
  <div id="bg">
    <div id="div-title">
      <h1 id="title-font"> Authority Management System </h1>
    </div>
    <div class="div-middle">
      <div class="div-bottom-middle"></div>
      <div class="div-bottom-middle">
        <div id="form-bg">
          <h2 id="login-font">Login</h2>
          <!--带有验证的表单:从文档复制来的,自己修改了部分内容-->
          <!--rules 属性传入约定的验证规则-->
          <!--prop 属性设置为需校验的字段名-->
          <!--设置表单: ref 绑定控件： ref="loginForm": 注册对象-->
          <!--:model是v-bind:model的缩写,用于绑定到return中的数据loginForm. v-model实现双向绑定数据:前端输入,vue字段接收;反之也成立-->
          <el-form :model="loginForm" :rules="rules"
                   ref="loginForm" label-width="25%"
                   class="demo-loginForm" label-position="left"
                   size="mini">
            <el-form-item label="账  号" class="label-font"  prop="username" >
              <el-input v-model="loginForm.username" placeholder="Username" class="inputtext"></el-input>
            </el-form-item>
            <el-form-item label="密  码"  class="label-font" prop="password">
              <el-input  v-model="loginForm.password" placeholder="Password" class="inputtext"></el-input>
            </el-form-item>
            <el-form-item label="验证码" class="label-font-code" prop="code" >
              <el-input v-model="loginForm.code" placeholder="Check Code" class="inputcode inputtext"></el-input>
              <!--这个元素用于防止校验码图像,src是图像路径-->
              <el-image src="" class="codeimg"></el-image>
            </el-form-item>
            <!--<el-form-item>-->
            <!--  -->
            <!--</el-form-item>-->
            <!--点击处罚按钮事件-->
            <el-button type="primary" @click="submitForm('loginForm')">登录</el-button>
            <el-button @click="resetForm('loginForm')">重置</el-button>

          </el-form>

        </div>
      </div>
      <div class="div-bottom-middle"></div>
    </div>
    <div id="div-bottom">
      <!--可以在这里写联系方式-->
    </div>
  </div>
</template>

<script>
export default {
  name: "Login",
  data() {
    return {
      loginForm: {
        username: '',
        password: '',
        code: '',
        // token用于获取验证码生成的随机码
        token: ''
      },
      // 表单校验规则
      rules: {
        username: [
          //  trigger:blur 当失去焦点的时候,触发规则验证
          // required: true 表示这个是必填选项
          { required: true, message: '请输入用户名', trigger: 'blur' },
        ],
        password: [
          { required: true, message: '请输入密码', trigger: 'blur' },
        ],
        code: [
          { required: true, message: '请输入验证码', trigger: 'blur' },
          { min: 5, max: 5, message: '长度为 5 个字符', trigger: 'blur' }
        ]
      }
    };
  },
  methods: {
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          alert('submit!');
        } else {
          console.log('error submit!!');
          return false;
        }
      });
    },
    // 重置信息
    resetForm(formName) {
      this.$refs[formName].resetFields();
    }
  }
}
</script>

<style scoped>
/*设置登录页的背景图像*/
#bg{
  background:url("../assets/bg1.jpg");
  /*大小设置为100%*/
  width:100%;
  height:100%;
  position: fixed;
  background-size:100% 100%;
  margin: -10px -10px -10px -10px;
  /*display: flex;*/
  /*align-items: center;*/
}
#div-title {
  width:100%;
  height:20%;
}
#title-font{
  color: white;
  text-align:center;
  padding: 3% 2% 9% 2%;
  /*自适应调整字体大小*/
  font-size: 4vw;
}
.div-middle{
  width:100%;
  height:55%;
  display: flex; /*将子元素设置成一行: 并等分*/
}
.div-bottom{
  width:100%;
  height:20%;
}
.div-bottom-middle{
  flex: 1; /*将子元素设置成一行: 并等分*/
}
#form-bg {
  height: 100%;
  width: 100%;
  /*使用rgba设置半透明的背景色*/
  background: rgba(248,248,255,0.5);
  border-radius: 6px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)
}
#login-font{
  font-size: 2vw;
  padding: 6% 2% 6% 2%;
  opacity:1
}
.el-form {
  padding: 0 2% 6% 5%;
}
.label-font{
  font-size: 1vw;
  padding: -10px 0 0 0;
}
.label-font-code{
  font-size: 1vw;
}
.inputtext{
  float: left;
  width: 80%;
  height: 100%;
  flex: 1; /*将子元素设置成一行: 并等分*/
}
.inputcode{
  width: 55%;
  height: 100%;
  flex: 1;
}
.codeimg{
  float: left;
  margin-left: 8px;
  border-radius: 4px;
}

</style>
```



#### Ⅱ. 验证码获取

##### **验证码获取的流程**

![image-20210513194037380](img/image-20210513194037380.png)

根据上图交互流程，请求生成验证码并验证真确性的过程需要参数（用户名、密码、验证码和随机码），因此在`loginForm`中增加字段token用来传递随机码。

由于生成验证码的过程需要和后端通信，而此时只有前端，因此我们使用mockjs来模拟后端生成随机数据，如下操作!



##### 使用mockjs模拟后端提供验证码图像和随机码

1. 在main.js中声明使用mockjs:`require("./mock.js")`

2. 与main.js同级新建一个`mock.js`，在其中模拟验证码请求'/captcha' 后的返回数据：

```js
// 引入mockjs,创建mockjs对象
const Mock = require('mockjs');
// 获取 mock.Random 对象
const Random = Mock.Random;
// 模拟数据的封装
let Result = {
    code: 200,
    msg: '操作成功',
    data: null
};
//模拟'/captcha'请求的返回结果:即模拟点击验证码图像后的响应结果
Mock.mock('/captcha', "get", () =>  {
    // 点击验证码图像响应后的返回结果:
    // 验证码的响应需要两个结果:token随机码和验证码图像
    Result.data = {
        // 生成的token随机码是一个32为数据
        token: Random.string(32),
        captchaImg: Random.dataImage('100x50', 'pn454')  // 注意这里的x是英文字母x,不然会报错
    }
    return Result
})
```

3. 在`Login.vue`前端页面中增加验证码请求的方法处理方法：

```vue
<script>
export default {
  ......
  methods: {
    getCaptcha(){  // 【捕获验证码图片的方法】
      // 点击验证码图片位置向后端发起异步请求,刷新创建新的验证码图片
      this.$axios.get('/captcha', this.loginForm).then(res =>{
        // 获取验证码对应的随机码：其中res.data表示结果, 第二个data表示结果中的属性data
        this.loginForm.token = res.data.data.token;  
        this.captchaImg = res.data.data.captchaImg  // 获取验证码图像
      })
    }
  } // methods
  created() {  // 一般可以在created函数中调用ajax获取页面初始化所需的数据。
    this.getCaptcha();   // 调用登录页验证码请求,来显示初始验证码
  }
}
</script>
```

4. 此时刷新界面就可以显示验证码了：

<img src="img/image-20210517181145526.png" alt="image-20210517181145526" style="zoom: 50%;" />



#### Ⅲ. 表单提交

##### 存储 jwt

如果表单信息校验成功、登录成功，应该要生成一个JWT并保存在header中，之后将JWT随header返回给前端。前端则会将JWT保存到 localStorage 中。以后每次访问时，就会携带jwt告诉后端，请求是谁发起的。



而 localStorage  存在于 `store`目录下的 `index.js` 文件中。这个目录下的文件中专门用来存储这种网络通信中的数据。因此下面先在`store->index.js`中存储后端传来的jwt。



在下面的程序中：state方法中的属性不能直接操作，因此可以在mutations方法中自定义方法来完成对state中属性的访问。

```js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
export default new Vuex.Store({
  state: {  // state中的变量不能直接操作,需要在mutations中解析
    token: ''
  },
  mutations: {
    // 为了操作state属性中的变量token,自定义一个SET_TOKEN方法
    SET_TOKEN: (state, token) => {  // 将后端传来的token注入state属性进行存储
      state.token = token
      localStorage.setItem("token", token)
    }
  },
  actions: {
  },
  modules: {
  }
})
```



##### 登录按钮事件响应

下面在Login.vue中，点击”登录“按钮触发的方法`submitForm()`中：

- 判断用户登录信息是否正确
- 异步刷新并路由跳转到登陆后的界面：
  - 获取jwt
  - 存储jwt
  - 路由跳转新页面

```vue
<script>
export default {
  ....其他属性代码省略....
    
  methods: {
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) { // 如果校验成功可以登录
          // 设置登录成功后的效果:从this.loginForm获取前端的结果
          // ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。
          // axios：提供了一些并发请求的接口（重要，方便了很多的操作）
          this.$axios.post('/login', this.loginForm).then(res =>{
            // 登录校验成功后,服务器会将JWT封装在header中并返回给客户端,
            // 客户端应该将jwt信息保存.之后每一次访问都将jwt发给后端用来快速验证
            const jwt = res.headers['authorization']  // 1.获取jwt
            // 2.浏览器存储jwt
            this.$store.commit("SET_TOKEN", jwt)

            // 完成以上工作后就可以进行界面跳转了,使用router进行跳转
            this.$router.push("/index")
          })
        } else {
          console.log('error submit!!');
          return false;
        }
      });
    }
    ....其他方法代码省略....
  }
}
```



##### 使用mock模拟用户信息完成登陆验证

在`mock.js`中模拟后端验证返回的结果：具体的验证对比不用写，这里只是位置测试

```js
// 引入mockjs,创建mockjs对象
const Mock = require('mockjs');
// 获取 mock.Random 对象
const Random = Mock.Random;
// 模拟数据的封装
let Result = {
    code: 200,
    msg: '操作成功',
    data: null
};
//模拟'/login'请求的返回结果:即模拟用户登录信息响应
Mock.mock('/login', "post", () =>  {
    // 无法在header中传入jwt
    return Result
})
```



##### 测试

登陆页面点击”登录“按钮后跳转到了index页面

![image-20210517185556755](img/image-20210517185556755.png)





#### Ⅳ. axios拦截

参考： https://www.jianshu.com/p/646ed4edf51f

1. 创建 admin-vue/src/axios.js。并在其中编写对request请求和response响应的拦截代码

```js
import axios from "axios";
import router from "./router";
import Element from "element-ui";
import {createConfig} from "http-proxy-middleware/dist/config-factory";
import {responseInterceptor} from "http-proxy-middleware";

// 定义axios的全局URL,不能与项目的url一样8080, 所以这里设置成8081端口
axios.defaults.baseURL = "http://localhost:8081"
// 定义一个对象, 可以统一设置超时时间等属性
const request = axios.create({
    timeout: 5000,
    headers: {
        'Content-Type': "application/json; charset=utf-8"
    }
})
// 下面进行拦截
// 首先拦截request请求
request.interceptors.request.use(config=>{
    config.headers['Authorization'] = localStorage.getItem("token")
    return config
})
// 然后拦截response响应
request.interceptors.response.use(response=>{
    let res = response.data // 获取response的数据西信息
    if (res.code === 200){ // 如果响应码是200,说明返回信息没有问题
        return response // 直接继续传递response
    }else{  // 如果响应码有问题,则拦截并报警
        Element.Message.error(!res.msg? '系统异常': res.msg)
        return Promise.reject(response.data.msg)  // 拒绝信息
    }
}, error =>{  // 如果过程中出现了一些异常,可以进一步判断 状态码是不是401等
    if (error.response.data){
        error.message = error.response.data.msg
    }
    if (error.response.status === 401){
        router.push("/login")
    }
    Element.Message.error(error.message,  {duration: 3000})
    return Promise.reject(error)
})
// 最后将request进行export
export default request
```

2. 在 main.js 中引用自定义的 axios ，代替默认的 axios

```js
// 手动2: 引入axios
// import axios from 'axios'
import axios from "./axios"  // 用自定义的axios代替默认的axios 
```

3. 测试：
   - 当验证码不是200，而是400。会报"系统异常"

![image-20210517194157249](img/image-20210517194157249.png)



#### 遇到的问题

node-sass和sass-loader版本不匹配：

node-sass5.0.0和sass-loader 10.1.1可以匹配

mockjs中：`Random.dataImage('100x50', 'pn454') 这里的x是英文字母x`





### 3.3 后台管理页面-首页

==src/views/index.vue==

#### Ⅰ. 创建基础页面 + 配置路由

1、在路由文件中给`index.vue页面`添加路由

```js
import Index from '../views/Index.vue'  // 1.显示后台默认页面
  {
    path: '/index',
    name: 'Index',
    component: Index
  },
```

2、index.vue页面 中创建布局（Container 布局容器）

```html
  <el-container id="all">
    <el-aside width="200px">Aside</el-aside>
    <el-container id="all1">
      <el-header>Header</el-header>
      <el-main>Main</el-main>
    </el-container>
  </el-container>
```

3、设计头部

```html
<!--1.设计头部-->
<el-header>
  <strong>后台管理界面</strong>
  <div class="headimg">
    <!--头像框-->
    <el-avatar class="userimg" size="medium">User</el-avatar>

    <!--下拉菜单-->
    <el-dropdown class="dropdown">
      <span class="el-dropdown-link">
        用户空间<i class="el-icon-arrow-down el-icon--right"></i>
      </span>
      <el-dropdown-menu slot="dropdown">
        <el-dropdown-item>个人中心</el-dropdown-item>
        <el-dropdown-item>退出</el-dropdown-item>
      </el-dropdown-menu>
    </el-dropdown>

    <!--页面内的网页跳转-->
    <el-link class="el-link-1" href="https://www.baidu.com/" target="_blank">网站</el-link>
    <el-link href="https://www.bilibili.com/video/BV1af4y1s7Wh?p=10&spm_id_from=pageDriver" target="_blank">视频</el-link>
  </div>
</el-header>
```

4、设计左侧导航栏

```html
<el-aside width="200px">
  <el-menu
      default-active="2"
      class="menu_total el-menu-vertical-demo"
      background-color="#545c64"
      text-color="#fff"
      active-text-color="#ffd04b">
      <!--@open="handleOpen"-->
      <!--@close="handleClose"-->

    <!--导航栏标题-->
    <el-menu-item>
      <template slot="title">
        <i class="el-icon-s-home"></i>
        <span><strong  class="toolbar-title">主页</strong></span>
      </template>
    </el-menu-item>


    <!--导航栏选项-->
    <el-submenu index="1">
      <template slot="title">
        <i class="el-icon-location"></i>
        <span>系统管理</span>
      </template>

      <el-menu-item index="1-1">
        <template slot="title">
          <i class="el-icon-user"></i>
          <span>用户管理</span>
        </template>
      </el-menu-item>
      <el-menu-item index="1-2">
        <template slot="title">
          <i class="el-icon-view"></i>
          <span>角色管理</span>
        </template>
      </el-menu-item>
      <el-menu-item index="1-3">
        <template slot="title">
          <i class="el-icon-menu"></i>
          <span>菜单管理</span>
        </template>
      </el-menu-item>
    </el-submenu>

    <el-submenu index="2">
      <template slot="title">
        <i class="el-icon-s-tools"></i>
        <span>系统工具</span>
      </template>
      <el-menu-item index="2-1">
        <template slot="title">
          <i class="el-icon-tickets"></i>
          <span>数字字典</span>
        </template>
      </el-menu-item>
    </el-submenu>
  </el-menu>
</el-aside>
```

5、综上，整个基础页面

```vue
<template>
  <el-container id="all">
    <!--2.设计左侧导航栏-->
    <!--===================================2.设计左侧导航栏=========================================-->
    <el-aside width="200px">
      <el-menu
          default-active="2"
          class="menu_total el-menu-vertical-demo"
          background-color="#545c64"
          text-color="#fff"
          active-text-color="#ffd04b">
          <!--@open="handleOpen"-->
          <!--@close="handleClose"-->

        <!--导航栏标题-->
        <el-menu-item>
          <template slot="title">
            <i class="el-icon-s-home"></i>
            <span><strong  class="toolbar-title">主页</strong></span>
          </template>
        </el-menu-item>


        <!--导航栏选项-->
        <el-submenu index="1">
          <template slot="title">
            <i class="el-icon-location"></i>
            <span>系统管理</span>
          </template>

          <el-menu-item index="1-1">
            <template slot="title">
              <i class="el-icon-user"></i>
              <span>用户管理</span>
            </template>
          </el-menu-item>
          <el-menu-item index="1-2">
            <template slot="title">
              <i class="el-icon-view"></i>
              <span>角色管理</span>
            </template>
          </el-menu-item>
          <el-menu-item index="1-3">
            <template slot="title">
              <i class="el-icon-menu"></i>
              <span>菜单管理</span>
            </template>
          </el-menu-item>
        </el-submenu>

        <el-submenu index="2">
          <template slot="title">
            <i class="el-icon-s-tools"></i>
            <span>系统工具</span>
          </template>
          <el-menu-item index="2-1">
            <template slot="title">
              <i class="el-icon-tickets"></i>
              <span>数字字典</span>
            </template>
          </el-menu-item>
        </el-submenu>
      </el-menu>
    </el-aside>

    <el-container id="all1">
      <!--===================================1.设计头部=========================================-->
      <el-header id="header">
        <strong>后台管理界面</strong>
        <div class="headimg">
          <!--头像框-->
          <el-avatar class="userimg" size="medium">User</el-avatar>

          <!--下拉菜单-->
          <el-dropdown class="dropdown">
            <span class="el-dropdown-link">
              用户空间<i class="el-icon-arrow-down el-icon--right"></i>
            </span>
            <el-dropdown-menu slot="dropdown">
              <el-dropdown-item>个人中心</el-dropdown-item>
              <el-dropdown-item>退出</el-dropdown-item>
            </el-dropdown-menu>
          </el-dropdown>

          <!--页面内的网页跳转-->
          <el-link class="el-link-1" href="https://www.baidu.com/" target="_blank">网站</el-link>
          <el-link href="https://www.bilibili.com/video/BV1af4y1s7Wh?p=10&spm_id_from=pageDriver" target="_blank">视频</el-link>
        </div>
      </el-header>
      <!--===================================3.设计主界面=========================================-->
      <el-main>


      </el-main>
    </el-container>
  </el-container>
</template>

<script>
export default {
  name: "Index",
  methods: {
    handleOpen(key, keyPath) {
      console.log(key, keyPath);
    },
    handleClose(key, keyPath) {
      console.log(key, keyPath);
    }
  }
}
</script>



<style scoped>
/*设置最大的容器*/
#all{
  padding: 0;
  margin: -10px -10px -10px -10px;
  height: 100%;
  width: 100%;
  position: fixed;
}
/*设置其中右侧的容器样式*/
#all1{
  padding: 0;
  margin: 0;
  height: 100%;
}

/*设置左侧菜单栏*/
.el-aside {
  background-color: darkslategray;
  color: #333;
  /*text-align: center;*/
  line-height: 200px;
}
/*设置右侧头部框*/
.el-header, .el-footer {
  background-color: palegoldenrod;
  color: #333;
  text-align: center;
  line-height: 60px;
  height: 20%;
}
/*设置右下主界面*/
.el-main {
  background-color: lightgoldenrodyellow;
  color: #333;
  text-align: center;
  line-height: 160px;
  height: 80%;
}
/*设置头像框div*/
.headimg{
  width: 250px;
  /*向右侧浮动,保持行内水平*/
  float: right;
  /*设置上下居中*/
  display: flex;
  align-items: center;
}
/*设置头像*/
.userimg{
  /*设置右侧外部间隔*/
  margin-right: 8px;
  /*设置背景图像*/
  background-image: url("../assets/touxiang.png");
  /*设置背景图像的大小*/
  background-size: cover;
}
/*下拉框*/
.dropdown{
  margin-right: 8px;
}
.el-link-1{
  margin-right: 8px;
}
/*设置下拉菜单属性*/
.el-dropdown-link {
  cursor: pointer;
  color: #6A5ACD;
  /*color: #409EFF;*/
}
.el-icon-arrow-down {
  font-size: 12px;
}

.menu_total{
  height: 100%;
  width: 200px;
  position: fixed;
  background-color: darkslategray;
  /*color: #333;*/
  text-align: left;
  line-height: 200px;
  float: left;
}
.toolbar-title{
  color: #FFA500;
}

</style>
```



#### Ⅱ. 抽取并建立公共页面

由于侧边栏和头部几乎在每一个界面都会出现，因此将这些部分抽取出来并放到单另的公共界面中，以便其他页面使用。



在`views`这个目录中新建子目录`inc`用来存放公共界面。在`inc`目录下创建如下几个子公共界面：



1、`SideMenu.vue`编写侧边栏样式

```vue
<template>
  <el-menu
      default-active="2"
      class="menu_total el-menu-vertical-demo"
      background-color="#545c64"
      text-color="#fff"
      active-text-color="#ffd04b">
    <!--@open="handleOpen"-->
    <!--@close="handleClose"-->

    <!--导航栏标题-->
    <el-menu-item>
      <template slot="title">
        <i class="el-icon-s-home"></i>
        <span><strong  class="toolbar-title">主页</strong></span>
      </template>
    </el-menu-item>


    <!--导航栏选项-->
    <el-submenu index="1">
      <template slot="title">
        <i class="el-icon-location"></i>
        <span>系统管理</span>
      </template>

      <el-menu-item index="1-1">
        <template slot="title">
          <i class="el-icon-user"></i>
          <span>用户管理</span>
        </template>
      </el-menu-item>
      <el-menu-item index="1-2">
        <template slot="title">
          <i class="el-icon-view"></i>
          <span>角色管理</span>
        </template>
      </el-menu-item>
      <el-menu-item index="1-3">
        <template slot="title">
          <i class="el-icon-menu"></i>
          <span>菜单管理</span>
        </template>
      </el-menu-item>
    </el-submenu>

    <el-submenu index="2">
      <template slot="title">
        <i class="el-icon-s-tools"></i>
        <span>系统工具</span>
      </template>
      <el-menu-item index="2-1">
        <template slot="title">
          <i class="el-icon-tickets"></i>
          <span>数字字典</span>
        </template>
      </el-menu-item>
    </el-submenu>
  </el-menu>
</template>

<script>
export default {
  name: "SideMenu"
}
</script>

<style scoped>
.menu_total{
  height: 100%;
  width: 200px;
  position: fixed;
  background-color: darkslategray;
  /*color: #333;*/
  text-align: left;
  line-height: 200px;
  float: left;
}
.toolbar-title{
  color: #FFA500;
}

</style>
```

2、`Header.vue` 提取头部

```vue
<template>
  <div>
  <strong>后台管理界面</strong>
  <div class="headimg">
    <!--头像框-->
    <el-avatar class="userimg" size="medium">User</el-avatar>

    <!--下拉菜单-->
    <el-dropdown class="dropdown">
            <span class="el-dropdown-link">
              用户空间<i class="el-icon-arrow-down el-icon--right"></i>
            </span>
      <el-dropdown-menu slot="dropdown">
        <el-dropdown-item>个人中心</el-dropdown-item>
        <el-dropdown-item>退出</el-dropdown-item>
      </el-dropdown-menu>
    </el-dropdown>

    <!--页面内的网页跳转-->
    <el-link class="el-link-1" href="https://www.baidu.com/" target="_blank">网站</el-link>
    <el-link href="https://www.bilibili.com/video/BV1af4y1s7Wh?p=10&spm_id_from=pageDriver" target="_blank">视频</el-link>
  </div>
  </div>
</template>

<script>
export default {
  name: "Header"
}
</script>

<style scoped>

/*设置头像框div*/
.headimg{
  width: 250px;
  /*向右侧浮动,保持行内水平*/
  float: right;
  /*设置上下居中*/
  display: flex;
  align-items: center;
}
/*设置头像*/
.userimg{
  /*设置右侧外部间隔*/
  margin-right: 8px;
  /*设置背景图像*/
  background-image: url("../../assets/touxiang.png");
  /*设置背景图像的大小*/
  background-size: cover;
}
/*下拉框*/
.dropdown{
  margin-right: 8px;
}
.el-link-1{
  margin-right: 8px;
}
/*设置下拉菜单属性*/
.el-dropdown-link {
  cursor: pointer;
  color: #6A5ACD;
  /*color: #409EFF;*/
}
.el-icon-arrow-down {
  font-size: 12px;
}
</style>
```



然后在`index.vue` 中引用这两个公共界面：

```vue
<template>
  <el-container id="all">
    <el-aside width="200px">
      <!--【 3. 使用已经引用的侧边栏的包 SideMenu 】-->
      <SideMenu></SideMenu>
    </el-aside>

    <el-container id="all1">
      <el-header id="header">
       <!--【 3. 使用已经引用的头部的包 Header】-->
        <Header></Header>
      </el-header>
      <el-main>
          主体
      </el-main>
    </el-container>
  </el-container>
</template>

<script>
// 【 1.引入SideMenu 侧边栏的包文件 】
import SideMenu from "@/views/inc/SideMenu";
import Header from "@/views/inc/Header";
export default {
  name: "Index",
  // 【 2. 在components声明嵌入的组件 】
  components: {
    SideMenu,
    Header
  }
}
</script>

<style scoped>
#all{
  padding: 0;
  margin: -10px -10px -10px -10px;
  height: 100%;
  width:100%;
  position: fixed;
}
#all1{
  padding: 0;
  margin: 0;
  height: 100%;
}
</style>
```



#### Ⅲ. 将页面转移到home页面

我们先理解一下页面逻辑：

App.vue中有:

```vue
<template>
  <div id="app">  【app是源码中的】
    <router-view/> 【这个router-view/会使程序自动进入路由文件中index.js，查找对应的请求】
  </div>
</template>
```

现在index.js 路由文件中设置三个一级请求（此时只用增加/home）：

```vue
const routes = [
  {
    path: '/home',
    children:[
      {
        path: '/index',
      }
    ]
  },
  {
    path: '/about',
  },
  {
    path: '/login',
  }
]
```

浏览器请求上面三个中任意一个请求会进入对应的页面。

然后，在/home中嵌入一个子请求`/index`。

将index中所有的代码移入home.vue中，使得index.vue中只显示主体部分：

```vue
<template>         【index.vue】
  <div>main</div>
</template>
<script>
export default {
  name: "Index"
}
</script>
```

home文件中显示其余节点，作为默认的父级节点。同时在home.vue中需要嵌入index.vue的地方使用<router-view>表示，路由文件中已经在/home中加入了children:[/index]作为这个页面中的一个子页面：

```vue
<template>
  <el-container id="all">
    <el-aside width="200px">
      <!--3. 使用已经引用的侧边栏的包-->
      <SideMenu></SideMenu>
    </el-aside>

    <el-container id="all1">
      <el-header id="header">
        <!-- 嵌入头部-->
        <Header></Header>
      </el-header>
      <el-main id="el-main">
        <!--当浏览器请求/index会异步显示这部分局部页面-->
        <router-view></router-view>                【这里嵌入子路由】
      </el-main>
    </el-container>
  </el-container>
</template>

<script>
// 1.引入SideMenu 侧边栏的包文件
import SideMenu from "@/views/inc/SideMenu";
import Header from "@/views/inc/Header";
export default {
  name: "Home",
  components: {
    Header,
    SideMenu,
  }
}
</script>

<!--css 样式表 =====================================-->
<style scoped>
</style>
```

**页面显示流程：**

- 程序启动后，最底层显示的是vue自带的APP.vue;

- App.vue有三个子页面：home、login、about。当浏览器请求这三个页面时，会先显示APP.vue,再显示这三个页面；

- 而当请求index.vue时，由于其是home页面的子页面，所以会先显示app页面，然后显示home页面，最后渲染index页面，所以尽管index只有一行代码，但是仍能显示home的底层页面。

**也就是说：多级嵌套的路由会先显示底层的父级页面模板，再叠加渲染子级模板**



### 3.4 添加主页中的子页面

==src/views/Login.vue==

#### Ⅰ. 创建页面文件

- views目录下创建sys目录

- 在这个目录下创建三个页面：`User.vue`  `Menu.vue`  `Role.vue`

#### Ⅱ. 配置几个页面的路由 

这三个文件都会作为home页面的子路由，因此在home页面的子路由下面配置这三个页面的路由：

```js
// 导入home页面的sys目录下的子路由
import Menu from "@/views/sys/Menu";
import Role from "@/views/sys/Role";
import User from "@/views/sys/User";

  {
    path: '/home',
    name: 'Home',
    component: Home,
    children:[   // 创建home页面的子路由
      {
        path: '/users',
        name: 'SysUser',
        component: User
      },
      {
        path: '/roles',
        name: 'SysRole',
        component: Role
      },
      {
        path: '/menus',
        name: 'SysMenu',
        component: Menu
      }
    ]
  }
```

浏览器输入任意一个请求验证显示结果，在页面主体部分会显示文字：

![image-20210603091248058](img/image-20210603091248058.png)



#### Ⅲ. 页面切换

经过上面的两步，直接在浏览器输入'/users' ,  '/roles',  '/menus' 这三个链接，在主页面中会显示简单的内容。但是直接点击左侧导航栏中的三个按钮不会进行切换，因为我们还没有将这三个按钮的路由添加到页面中。下面进行配置。



这三个按钮出现在`SideMenu.vue`导航页面中。因此在出现这三个页面的标签前后包裹`<router-link to=""></router-link>`

```vue
<template>
  <el-menu
      default-active="2"
      class="menu_total el-menu-vertical-demo"
      background-color="#545c64"
      text-color="#fff"
      active-text-color="#ffd04b">
    <!--@open="handleOpen"-->
    <!--@close="handleClose"-->

    <!--导航栏标题-->
    <router-link to="/index">             【包裹router-link】
      <el-menu-item>
        <template slot="title">
          <i class="el-icon-s-home"></i>
          <span><strong class="toolbar-title">主页</strong></span>
        </template>
      </el-menu-item>
    </router-link>                        【包裹router-link】

    <!--导航栏选项-->
    <el-submenu index="1">
      <template slot="title">
        <i class="el-icon-location"></i>
        <span>系统管理</span>
      </template>

      <router-link to="/users">            【包裹router-link】
        <el-menu-item index="1-1">
          <template slot="title">
            <i class="el-icon-user"></i>
            <span>用户管理</span>           
          </template>
        </el-menu-item>
      </router-link>                       【包裹router-link】
        
      <router-link to="/roles">            【包裹router-link】 
        <el-menu-item index="1-2">
          <template slot="title">
            <i class="el-icon-view"></i>
            <span>角色管理</span>
          </template>
        </el-menu-item>
      </router-link>                       【包裹router-link】
        
      <router-link to="/menus">            【包裹router-link】
        <el-menu-item index="1-3">
          <template slot="title">
            <i class="el-icon-menu"></i>
            <span>菜单管理</span>
          </template>
        </el-menu-item>
      </router-link>                       【包裹router-link】
    </el-submenu>

    <el-submenu index="2">
      <template slot="title">
        <i class="el-icon-s-tools"></i>
        <span>系统工具</span>
      </template>
      <el-menu-item index="2-1">
        <template slot="title">
          <i class="el-icon-tickets"></i>
          <span>数字字典</span>
        </template>
      </el-menu-item>
    </el-submenu>


  </el-menu>
</template>

```

现在点击左侧导航栏中的三个按钮就会有 Ⅱ 中的显示效果，说明页面内的路由链接成功



### 3.5 用户信息展示

#### 3.5.1 头像和用户名

点击右上角用户头像相关的链接应该显示用户的详细信息。

`Header.vue`中修改相关代码

```
相关知识点补充：
vue中在methods属性的作用：
	1.使用methods属性给vue定义方法
	2.在方法中使用this.属性名就可以直接访问data中的数据
	3.在构造函数外部可以使用vm.方法名定义或者调用方法
	
vue中data()方法的作用：
	1.起到局部变量的作用。 return的变量和方法只限于当前声明此data（）的组件使用
	2.指定设置当前vue实例所使用的数据，data的值可以是一个对象
	3.响应式数据（当数据发生变化的时候，视图中的数据会自动发生变化）
```

下面首先修改`Header.vue` 中的代码将头像显示和用户名显示进行更改

```vue
<template>
  <el-header id="header">
      .......
    <div class="headimg">
      <!--头像框--> <!--:src 传入用户头像-->
      <el-avatar :src="userInfo.avatar"  【userInfo.avatar传入mockjs头像图片】
                 class="userimg" size="medium" >User
      </el-avatar>
      <!--下拉菜单-->
      <el-dropdown class="dropdown">
            <span class="el-dropdown-link">
              <!--传入用户名-->
              {{userInfo.username}}    【{{userInfo.username}}传入用户名字符串】
              <i class="el-icon-arrow-down el-icon--right"></i>
            </span>
      </el-dropdown>
    </div>
  </el-header>
</template>

<script>
export default {
  name: "Header",
  data(){                    
  // 向这个页面(头部)返回用户信息  
  return {                         【data属性中return 返回参数并供本页面节点使用】
      userInfo: {
        id: "",
        username: "",
        avatar: ""
      }
    }
  },
  // 在methods中定义用户方法
  methods: {                     【methods属性中自定义方法】
    getUserInfo(){               【getUserInfo()属性中】
      this.$axios.get("/sys/userInfo").then(res=>{
        this.userInfo = res.data.data
      })
    }
  },
  created() { // 接收调用用户方法
    this.getUserInfo()  // 页面加载的时候获取用户信息
  }
}
</script>

```

然后再mockjs中模拟用户信息

```js
//模拟'/sys/userInfo' 请求  获取用户信息
Mock.mock('/sys/userInfo', "get", () =>  {
    Result.data = {
        // 根据Header.vue中data() return的结果,返回对应的用户信息
        id: "1",
        username: "nini",
        avatar: "https://img.zcool.cn/community/01129957723f4b0000018c1b6692bb.jpg@1280w_1l_2o_100sh.jpg"
    }
    return Result
})
```



#### 3.5.2 下拉菜单--个人中心

头部的用户`下拉菜单`中有一个`个人中心`。点击后应该出现如下页面：

![image-20210607134632116](img/image-20210607134632116.png)

首先在前端页面`Header.vue`中出现`个人中心`链接的地方增加`router-link`:

```vue
<!--下拉菜单-->
<el-dropdown class="dropdown">
  <span class="el-dropdown-link">
    <!--传入用户名-->
    {{userInfo.username}}<i class="el-icon-arrow-down el-icon--right"></i>
  </span>
  <el-dropdown-menu slot="dropdown">
    <el-dropdown-item>
      <!--<router-view></router-view>-->
      <router-link :to="{name: 'userCenter'}">个人中心</router-link>
    </el-dropdown-item>
    <el-dropdown-item>退出</el-dropdown-item>
  </el-dropdown-menu>
</el-dropdown>
```

然后将这个页面作为home页面下的子路由:

```js
{ // 下拉菜单的个人中心页
  path: '/userCenter',
  name: 'userCenter',
  component: ()=> import("@/views/UserCenter.vue")
},
```

编写`UserCenter.vue`页面逻辑：

```vue
<template>
  <div>
    <el-form id="form1" :model="passForm" status-icon :rules="rules" ref="passForm" label-width="100px" class="demo-ruleForm">
      <h2 id="tit1">修改密码</h2>
      <el-form-item label="旧密码" prop="currentPass">
        <el-input type="password" v-model="passForm.currentPass" autocomplete="off"></el-input>
      </el-form-item>
      <el-form-item label="新密码" prop="password">
        <el-input type="password" v-model="passForm.password" autocomplete="off"></el-input>
      </el-form-item>
      <el-form-item label="确认密码" prop="checkPass">
        <el-input type="password" v-model="passForm.checkPass" autocomplete="off"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="submitForm('passForm')">提交</el-button>
        <el-button @click="resetForm('passForm')">重置</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  name: "Home",
  data() {
    var validatePass = (rule, value, callback) => {
      if (value === '') {
        callback(new Error('请再次输入密码'));
      } else if (value !== this.passForm.password) {
        callback(new Error('两次输入的密码不一致!'));
      } else {
        callback();
      }
    };
    return {
      userInfo: {
      },
      passForm: {
        password: '',
        checkPass: '',
        currentPass: ''
      },
      rules: {
        password: [
          { required: true, message: '请输入新密码', trigger: 'blur' },
          { min: 6, max: 12, message: '长度在6到12个字符', trigger: 'blur'}
        ],
        checkPass: [
          { required: true, validator: validatePass, trigger: 'blur' }
        ],
        currentPass: [
          { required: true, message: '请输入当前密码', trigger: 'blur' }
        ]
      }
    };
  },
  created(){
    this.getUserInfo()
  },
  methods: {
    getUserInfo() {
      this.$axios.get("/sys/userInfo").then(res => {
        this.userInfo = res.data.data;
      })
    },
    submitForm(formName) {
      this.$refs[formName].validate((valid) => {
        if (valid) {
          const _this = this
          this.$axios.post('/sys/user/updataPass', this.passForm).then(res => {
            _this.$alert(res.data.msg, '提示', {
              confirmButtonText: '确定',
              callback: action => {
                this.$refs[formName].resetFields();
              }
            });
          })
        } else {
          console.log('error submit!!');
          return false;
        }
      });
    },
    resetForm(formName) {
      console.log("重置")
      this.$refs[formName].resetFields();
    }
  }
}
</script>

<style scoped>
#form1{
  /*text-align: center;*/
  width: 420px;
  margin: -20px auto;
}
#tit1 {
  margin-bottom: -20px;
  color: cornflowerblue;
  text-shadow: 1px 1px 8px sandybrown;
}
</style>
```



#### 3.5.3 下拉菜单--退出

点击下拉菜单中的`退出` 会有对应的退出操作。需要给这个标签增加一个事件。在`Header.vue` 中出现退出的地方增加点击事件：

```vue
<!--下拉菜单-->
<el-dropdown class="dropdown">
  <el-dropdown-menu slot="dropdown">
   
    【由于这个el标签不支持click事件，因此在后面增加native，就可以实现点击事件了】
    <el-dropdown-item @click.native="logout">  
        退出
    </el-dropdown-item>
  </el-dropdown-menu>
</el-dropdown>
```

在 `Header.vue` 中的 script 中编写 `logout` 事件代码：

```vue
<script>
export default {
  name: "Header",
  data(){
    return {   // 向这个页面(头部)返回用户信息
    }
  },
  methods: { // 在methods中定义用户方法
    logout(){                          【自定义这个方法，用于处理退出】
        // 清除缓存状态
        localStorage.clear()
        sessionStorage.clear()
        this.$store.commit("resetState")
        // 进行页面跳转
        this.$router.push("/login")
      })
    },
  },
}
</script>
```

在`store` 全局状态目录中的 `index.js` 文件中编辑 `resetState`方法将全局token 缓存清除：

```js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

export default new Vuex.Store({
  state: {  // state中的变量不能直接操作,需要在mutations中解析
    token: ''
  },
  mutations: {
    【 当退出登陆时，这个方法用于清除部分状态变量的缓存
    resetState: (state) => {
      state.token = ''
    }
  },
  actions: {
  },
  modules: {
  }
})
```

在mockjs中模拟创建数据：

```js
// 模拟退出 的数据
Mock.mock('/logout', "post", () =>  {
    return Result
})
```

此时点击会跳回 登录页面





### 3.6 动态导航与动态路由绑定

1. 修改页面，使用json数组修改固定的模板
2. 编辑导航栏 mockjs数据
3. 在store目录文件中创建导航栏的全局参数
4. 在路由文件中编写 导航钩子，进行用户请求拦击
5. 在 SideMenu.vue 侧边导航栏页面中获取 用户信息和导航信息并显示在模板中



####  修改导航栏

下面对左侧导航栏进行修改。

由于最后需要根据用户的权限来显示不同的菜单项，进而显示不同的页面数据。因此不能将左侧的菜单栏如同上面一样写死了。

将 `SideMenu.vue` 中 `<template>` 的 节点简化成 json 数组，然后使用 for 循环展示出来：

```vue
<template>
  <el-menu
      default-active="2"
      class="menu_total el-menu-vertical-demo"
      background-color="#545c64"
      text-color="#fff"
      active-text-color="#ffd04b">
    <!--@open="handleOpen"-->
    <!--@close="handleClose"-->

    <!--导航栏标题-->
    <router-link to="/index">
      <el-menu-item index="0">
        <template slot="title">
          <i class="el-icon-s-home"></i>
          <span><strong class="toolbar-title">主页导航</strong></span>
        </template>
      </el-menu-item>
    </router-link>

    <!--导航栏选项-->      【下面开始同样的显示用json数组循环展示】
    <el-submenu :index="menu.name" v-for="menu in menuList"> 【循环遍历script中的menuList】
      <template slot="title">     
        <i :class="menu.icon"></i>   【将图标改成json数组中的值】
        <span>{{menu.title}}</span>  【将导航名字改成json数组中的值】
      </template>

      <router-link :to="item.path" v-for="item in menu.children"> 【将请求路径改成json值】
        <el-menu-item :index="item.name"> 【将index改成json数组中的值】
          <template slot="title">
            <i :class="item.icon"></i>
            <span>{{item.title}}</span>
          </template>
        </el-menu-item>
      </router-link>

    </el-submenu>
  </el-menu>
</template>

<script>
export default {
  name: "SideMenu",
  data() {
    return {
      menuList: [      【按照原来的导航栏结构构建 图标、标题、请求路径等的json数组】
        {
          // 构建菜单栏的json数组
          name: 'SysMange',
          title: '系统管理',
          icon: 'el-icon-location',
          path: '',
          children: [
            {
              name: 'SysUser',
              title: '用户管理',
              icon: 'el-icon-user',
              path: '/sys/users',
              children: []
            }
          ]
        },
        {
          name: 'SysTools',
          title: '系统工具',
          icon: 'el-icon-s-tools',
          path: '',
          children: [
            {
              name: 'SysDict',
              title: '数字字典',
              icon: 'el-icon-tickets',
              path: '/sys/dicts',
              children: []
            }
          ]
        }
      ]
    }
  },
  methods: {
    
  }
}
</script>

<style scoped>
    ....
</style>
```

<img src="img/image-20210607161730054.png" alt="image-20210607161730054" style="zoom: 50%;" />



#### 导航栏的mockjs

创建导航栏的mockjs数据，以便之后不同权限的用户显示不同的导航菜单：

其中Result返回的数据包括：导航栏信息 nav 和用户权限信息 authoritys

```js
// 引入mockjs,创建mockjs对象
const Mock = require('mockjs');
// 获取 mock.Random 对象
const Random = Mock.Random;
// 模拟数据的封装
let Result = {
    code: 200,
    msg: '操作成功',
    data: null
};
Mock.mock('/sys/menu/nav', "get", () =>  {
    // nav中是导航栏的信息
    let nav = [
        {
            // 构建菜单栏的json数组
            name: 'SysMange',
            title: '系统管理',
            icon: 'el-icon-location',
            path: '',
            component: '',
            children: [
                {
                    name: 'SysUser',
                    title: '用户管理',
                    icon: 'el-icon-user',
                    path: '/sys/users',
                    component: 'sys/User',
                    children: []
                }
            ]
        },
        {
            name: 'SysTools',
            title: '系统工具',
            icon: 'el-icon-s-tools',
            path: '',
            component: '',
            children: [
                {
                    name: 'SysDict',
                    title: '数字字典',
                    icon: 'el-icon-tickets',
                    path: '/sys/dicts',
                    component: '',
                    children: []
                }
            ]
        }
    ]
    // authoritys是用户权限信息
    let authoritys = []
    // 将两个信息放到返回的结果中
    Result.data = {
        nav: nav,
        authoritys: authoritys
    }
    return Result
})
```



#### 导航钩子拦截用户请求

1. 当要进入主页后根据不用的用户身份应该显示不同的导航栏标题，此时导航栏发起一个请求。

2. 在路由文件`/router/index.js`中根据这个请求获取不同用户的权限信息和应该显示的导航项目，这一步使用`router.beforeEach` 导航钩子来实现
3. 导航钩子拦截router，获取到不同用户的权限，和导航信息后，将这两个信息通过store.state.commit（）传递到store 目录下的全局参数文件中进行缓存：
   - `store.state.commit`：同步操作，将数据提交至 `mutations` 。括号中的参数：
     - 第一个参数：对应文件menus.js的属性mutations中的方法
     - 第二个参数：要传递到mutations方法中对应的参数

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
// 1.手动导入需要使用路由的页面
import Home from '../views/Home.vue'
import Index from '../views/Index.vue'  // 1.默认显示页面
import Login from '../views/Login.vue'  // 2.登录首页
// 2. 导入home页面的sys目录下的子路由
import Menu from "@/views/sys/Menu";
import Role from "@/views/sys/Role";
import User from "@/views/sys/User";
import UserCenter from "@/views/UserCenter";
import {fromJson} from "cli-highlight";
import axios from "axios"
import {reset} from "colorette";
// 导入全局参数的目录store
import store from "../store"            【首先引入store全局状态参数目录】

Vue.use(VueRouter)
// 新增的路由在routes中增加
const routes = [
  {
    path: '/home',
    name: 'Home',
    component: Home,
    children:[   // 创建home页面的子路由
    ]
  }
]
const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes
})

// 在这里面判断不同用户的请求路径是否存在
// 首先导入 import axios from "axios"
// 然后编写下面的逻辑
router.beforeEach((to, fromJson,  next) => {【然后编写导航钩子，在跳转前实现权限用户的路径判断】
  // axios.get: 发起获取左侧导航栏信息的请求
  axios.get("/sys/menu/nav", {
    headers: {
      Authorization: localStorage.getItem("token")
    }
  }).then(res => {
    // 从mockjs中获取result返回值: nav和 authoritys
    // 拿到 menuList导航栏标题信息： nav
    store.commit("setMenuList", res.data.data.nav);
    // 拿到用户权限信息: authoritys
    store.commit("setPermList", res.data.data.authoritys);

  })
  next()
})

export default router
```



#### 导航栏的全局参数

获取来自导航钩子的 用户信息和导航信息：

在`store/modules/menus.js`中 编辑属于导航栏组件的 参数及状态，然后将menus.js 引入 store目录下的全局参数状态文件`index.js`中。将导航栏的参数独立到menus.js中的好处是，避免全局参数文件变得冗余复杂，保证了模块与模块之间的参数独立性。 `menus.js`及 `index.js` 中的具体实现如下：

```js
menus.js 全局参数状态文件：
==============================================================
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
export default{   【注意这里：不用new..】
    state: {  // 导航栏模块使用到的全局参数包括两个: 导航列表,用户权限
        menuList: [],      【导航列表参数】
        permList: []       【用户权限参数】
    },
    mutations: {         
        setMenuList(state, menus) {   【在这里编写操作两个参数的set方法】
            state.menuList = menus
        },
        setPermList(state, perms) {
            state.permList = perms
        }
    },
    actions: {
    }
}
```

```js
index.js 全局参数状态文件：
==============================================================
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

// 手动引入其他组件模块的参数状态
import menus from "./modules/menus"              【在这里引入导航栏的参数文件】

export default new Vuex.Store({
  state: {  // state中的变量不能直接操作,需要在mutations中解析
    //这里放全局参数
    token: ''
  },
  mutations: {
    //这里是set方法
    // 为了操作state属性中的变量token,自定义一个SET_TOKEN方法
    SET_TOKEN: (state, token) => {  // 将后端传来的token注入state属性进行存储
      state.token = token
      localStorage.setItem("token", token)
    },
    resetState: (state) => {
      state.token = ''
    }
  },
  getters: {
    //get方法
  },
  actions: {
  },
  modules: {
    // 这里是我自己理解的是为了给全局变量分组，
    // 所以需要写提前声明其他store文件，然后引入这里
    menus                                 【在modules中引入导航栏参数】
  }
})
```



#### SideMenu.vue 获取信息

将store 全局参数文件（缓存）中的用户信息和导航标题信息传递到前端vue页面中。将页面中的script 改成下面的样子：

```vue
<script>
export default {
  name: "SideMenu",
  data() {
    return {}
  },
  computed: {       【在computed中获取store全局参数文件中的信息】
    menuList: {     【menuList导航列表信息： 对应menus.js中state的参数名】
      get() {        
        return this.$store.state.menus.menuList 【向模板中返回对应的参数】
      }
    }
  },
  methods: {}
}
</script>
```



此时页面可以正常显示导航栏了：

![image-20210609201535351](img/image-20210609201535351.png)



#### 动态绑定路由

首先在`/store/modules/menus.js` 中定义一个全局状态`hasRoute`，用来记录导航栏路由是否更新：

```js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
export default{
    state: {
        // 定义一个导航栏相关route 是否更新的标志
        hasRoute: false
    },
    mutations: {
        // 获取导航栏状态是否改变了的方法
        changeRouteStatus(state, hasRoute){
            state.hasRoute = hasRoute
            // sessionStorage.setItem("hasRoute", hasRoute)
        }
    },
    actions: {
    }
}
```



然后在路由文件中动态绑定导航栏路由：

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import axios from "axios"
// 导入全局参数的目录store
import store from "../store"

Vue.use(VueRouter)

// 新增的路由在routes中增加
const routes = [
  {
    path: '/home',
    name: 'Home',
    component: Home,
    children:[   // 创建home页面的子路由 
      { // 下拉菜单的个人中心页
        path: '/userCenter',
        name: 'userCenter',
        component: UserCenter // ()=> import("@/views/UserCenter.vue")
      },
        【home 有三个子路由：'/sys/users','/sys/roles','/sys/menus',】
        【不在这里写死了，而是在加载页面的时候通过获取用户信息进行这三个子路由的动态绑定】
    ]
  },
]

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes
})

router.beforeEach((to, fromJson,  next) => { 【在beforeEach导航钩子中更新路由】
  // 首先从store中获取hasRoute参数,判断导航栏路由状态是否更新了
  let hasRoute = store.state.menus.hasRoute
  // 如果还没有更新过,则进行更新
  if(!hasRoute){
    // axios.get: 发起获取左侧导航栏信息的请求
    axios.get("/sys/menu/nav", {
        ......代码省略.......
    }).then(res => {
      // 从后端获取result返回值: nav和 authoritys ，即menuList导航列表信息
      store.commit("setMenuList", res.data.data.nav);
       
        ......代码省略.......
        
      // 动态绑定路由
      // 1.首先获取当前的路由newRoutes ,即 const routes ={}
      let newRoutes = router.options.routes    【这一行开始下面每一行都是 路由动态绑定的代码】
      // 2.循环遍历导航栏信息res.data.data.nav,获取其中的子导航项目
      res.data.data.nav.forEach(menu => {
        // 3.判断如果此导航标题有子标题,则绑定每一个子标题的路由
        if(menu.children){
          menu.children.forEach(submenu => {
            // 4.路由转换: 在自定义的方法中实现 获取mockjs中的导航栏信息并转换成route的形式
            let route = menuToRoute(submenu);
            // 5.把路由添加到1获取的当前路由中:
            if (route){
              newRoutes[0].children.push(route)
            }
          })
        }
      })
      // 将当前的新路由添加到 全局的router中
      router.addRoutes(newRoutes)
      // 改变hasRoute的状态
      hasRoute = true
      // 将hasRoute状态更新到changeRouteStatus方法中保存
      store.commit("changeRouteStatus", hasRoute)
    })
  }
  // beforeEach 最后必须要有next()才会跳转
  next()

})

// 自定义实现路由转换的方法
const menuToRoute = (menu) => {
  // 1.首先判断 component 是否为空: 不为空才进行路由转换
  if (!menu.component){ return null;}
  // 2.component不为空,进行路由转换
  let route = {
    // 3.根据mockjs中的数据进行转换[这就是具体的转换过程]
    // name: 'SysUser',
    // title: '用户管理',
    // icon: 'el-icon-user',
    // path: '/sys/users',
    // component: 'sys/User',
    // children: []
    name: menu.name,
    path: menu.path,
    meta: {
      icon: menu.icon,
      title: menu.title
    }
  }
  // 3.component与上面的格式不同,所有进行单独转换
  route.component = () => import('@/views/' + menu.component + '.vue')
  // 4.最后返回转换后的局部路由
  return route
}
export default router
```



此时点击`用户管理`时，导航栏显示的url是`http://localhost:8080/sys/users`。

其中`/sys/users`是 `用户管理`的路由对应的请求。而这个请求是根据传入的用户后台数据动态变更的。

当后台指定`用户管理`对应的路由请求是别的url时，地址栏就会动态更改。

从而实现了不同权限用户的导航栏动态显示。

![image-20210611173442580](img/image-20210611173442580.png)